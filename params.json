{"name":"Wookiee-spray","tagline":"Wookiee Component - Spray","body":"# Wookiee - Component: Spray (HTTP)\r\n\r\n[![Build Status](https://travis-ci.org/Webtrends/wookiee-spray.svg?branch=master)](https://travis-ci.org/Webtrends/wookiee-spray) [![Coverage Status](https://coveralls.io/repos/Webtrends/wookiee-spray/badge.svg?branch=master&service=github)](https://coveralls.io/github/Webtrends/wookiee-spray?branch=master) [![Latest Release](https://img.shields.io/github/release/webtrends/wookiee-spray.svg)](https://github.com/Webtrends/wookiee-spray/releases) [![License](http://img.shields.io/:license-Apache%202-red.svg)](http://www.apache.org/licenses/LICENSE-2.0.txt)\r\n\r\n[Main Wookiee Project](https://github.com/Webtrends/wookiee)\r\n\r\nFor Configuration information see [Spray Config](docs/config.md)\r\n\r\nThe Spray component has both server and client http functionality. The server component will allow connections to the service using spray. The client will allow the user to make requests and receive responses using the Akka actor methodology as it's based. Both are started up if using as a service. If using as a library if you start up the SprayManager manually both server and client will start up.\r\n\r\nFor working example see [Wookiee - Http Example](example-http) or [Wookiee - Rest Example](example-rest)\r\n\r\n## Config\r\n```json\r\nwookiee-spray {\r\n  manager = \"com.webtrends.harness.component.http.SprayManager\"\r\n  enabled = true\r\n\r\n  # The port to run the http server on\r\n  http-port = 8080 \r\n\r\n  # The port to run the websocket server on\r\n  http-port = 8081 \r\n}\r\nspray {\r\n  can {\r\n    server {\r\n      server-header = \"harness\"\r\n      request-timeout = 60s\r\n      idle-timeout = 120s\r\n\r\n      # Enables/disables the addition of a `Remote-Address` header\r\n      # holding the clients (remote) IP address.\r\n      remote-address-header = on\r\n      # Enables/disables support for statistics collection and querying.\r\n      stats-support = on\r\n    }\r\n    parsing {\r\n      max-uri-length: 16k\r\n    }\r\n  }\r\n  client {\r\n    idle-timeout = 120 s\r\n    request-timeout = 60 s\r\n  }\r\n  host-connector {\r\n    max-connections = 10\r\n    max-retries = 2\r\n    pipelining = on\r\n  }\r\n}\r\nakka.actor.deployment {\r\n  /system/component/wookiee-spray/spray-server/spray-base {\r\n    router = round-robin\r\n    nr-of-instances = 3\r\n  }\r\n}\r\n```\r\n\r\nThe configuration is fairly straight forward and generally you wouldn't modify these settings too much. The Spray settings are all found in here. So if you need to modify any Spray settings you would just modify them under the Spray key as seen in the example config above.\r\n\r\n## Spray Server\r\nThe SprayManager which is the core component for the Spray component module, extends the SprayServer with the SprayClient and SprayWebSocketServer. The SprayServer, SprayClient and SprayWebsocketServer are started as child actors for the root actor (for this component) SprayManager.\r\n\r\n### Adding a route to the server\r\nThe primary function of having a http server is to allow requests to be made to your service and a subsequent response after some business logic is executed. The easiest way to do this would be to simply create Commands and have Wookiee add the routes automatically. However, a developer can also build the routes for more complicated usage. The routes are based on Spray so for more information on building the routes themselves, head over to [Spray.io Documentation](http://spray.io/documentation/1.2.2/). To add routes manually you can do the following:\r\n```Scala\r\nclass MyService extends SprayService {\r\n  override def routes:Routes = manualRoute // or simply create the route inline\r\n\r\n  def manualRoute:Route = {\r\n    pathPrefix(Segment / \"foo\" / Segment / \"bar\") {\r\n      (seg1, seg2) =>\r\n        path(\"request\") {\r\n          get {\r\n            ctx => ctx.complete(\"Hello World!\")\r\n          }\r\n        }\r\n    }\r\n  }  \r\n}\r\n```\r\nAs you will notice this is no different from how you would create a route in previous versions of Wookiee (Harness) except for extending from SprayService instead of Service. As in previous versions the Plugin (which has been changed to Service) class by default had http built into it. HTTP now is a separate component and used only when requested. SprayService extends from Service and brings all the base functionality of Service along with it. There is also no requirement that a service needs to have http built into it, like using SprayService. If you use commands exclusively your service does not need to extend SprayService\r\n\r\n#### Adding routes automagically\r\nThe ability to add routes automagically is as easy as mixing in traits into your commands. See [SprayRoutes](docs/SprayRoutes.md) for more information about this.\r\n\r\n## Spray Client\r\nSee [SprayClient](docs/SprayClient.md)\r\n\r\n## Spray WebSocket Server\r\nThe websocket server allows requests to be made to your service with a response after some business logic has been executed. This is accomplished by creating WebSocketWorkers and registering the endpoint they service with Wookiee.\r\nA websocket worker is created by extending the ```WebSocketWorker``` trait and overriding businessLogic as follows:\r\n```Scala\r\nclass ServerWorker extends WebSocketWorker {\r\n\r\n  override def businessLogic = ({\r\n    case x: BinaryFrame =>\r\n      log.info(\"Server BinaryFrame Received:\" + x)\r\n      sender() ! x\r\n\r\n    case x: TextFrame =>\r\n      if (x.payload.length <= 10) {\r\n        log.info(\"Server TextFrame Received:\" + x)\r\n        sender() ! x\r\n      } else {\r\n        log.info(\"Server Large TextFrame Received:\" + x)\r\n        sender() ! TextFrameStream(1, new ByteArrayInputStream(x.payload.toArray))\r\n      }\r\n\r\n    case x: HttpRequest =>\r\n      log.info(\"Server HttpRequest Received\")\r\n\r\n    case x: Tcp.ConnectionClosed =>\r\n      log.info(\"Server Close\")\r\n  }: Receive) orElse super.businessLogic\r\n}```\r\n\r\n### Adding a WebSocket endpoint to the websocket server\r\nEndpoints can be added to the WebSocket server by implementing the addWebSocketWorkers function in your service and mapping paths to workers.  An actor will be created for each connection made to the endpoint.  \r\nThe endpoint path will be parsed allowing users to get parameters from the URL. A URL like '/account/1/user/2/obj/3' can be created with the string '/account/$accId/user/$userId/obj/$objId'. This will then match the URL and assume that any of the path elements starting with $ are variables. The variables will be placed in the CommandBean and can be retrieved in the WebSocketWorker' businessLogic using the keys accId, userId and objId. The variables will automatically be converted to Integers if it is not a String.\r\n```Scala\r\nclass MyService extends SprayService {\r\n  override def addWebSocketWorkers = {\r\n    addWebSocketWorker(\"test\", classOf[ServerWorker])\r\n    addWebSocketWorker(\"endpoint2\", classOf[MyServerWorker2])\r\n    addWebSocketWorker(\"account/$accId/user/$userId/obj/$objId\", classOf[MyServerWorker3])\r\n  }\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}